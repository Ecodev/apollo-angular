(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{251:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return m}));var o=n(0),a=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=a.a.createContext({}),d=function(e){var t=a.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=d(e.components);return a.a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},f=a.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),u=d(n),f=o,m=u["".concat(r,".").concat(f)]||u[f]||p[f]||i;return n?a.a.createElement(m,s(s({ref:t},c),{},{components:n})):a.a.createElement(m,s({ref:t},c))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=f;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=n[c];return a.a.createElement.apply(null,r)}return a.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},94:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return l})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var o=n(1),a=n(8),i=(n(0),n(251)),r=["components"],s={title:"Pagination"},l={unversionedId:"data/pagination",id:"data/pagination",isDocsHomePage:!1,title:"Pagination",description:"Sometimes, you will have one or more views in your application where you need to display a list that contains too much data to be either fetched or displayed at once. Pagination is the most common solution to this problem, and Apollo Client has built-in functionality that makes it quite easy to do.",source:"@site/docs/data/pagination.md",slug:"/data/pagination",permalink:"/docs/data/pagination",editUrl:"https://github.com/kamilkisiela/apollo-angular/edit/master/website/docs/data/pagination.md",version:"current",sidebar:"docs",previous:{title:"Network layer",permalink:"/docs/data/network"},next:{title:"Using Fragments",permalink:"/docs/data/fragments"}},c=[{value:"Offset-based",id:"offset-based",children:[{value:"The <code>offsetLimitPagination</code> helper",id:"the-offsetlimitpagination-helper",children:[]},{value:"Using <code>fetchMore</code>",id:"using-fetchmore",children:[]},{value:"Setting <code>keyArgs</code> with <code>offsetLimitPagination</code>",id:"setting-keyargs-with-offsetlimitpagination",children:[]}]},{value:"Cursor-based",id:"cursor-based",children:[]},{value:"Relay-style cursor pagination",id:"relay-style-cursor-pagination",children:[]}],d={toc:c};function u(e){var t=e.components,n=Object(a.a)(e,r);return Object(i.b)("wrapper",Object(o.a)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"Sometimes, you will have one or more views in your application where you need to display a list that contains too much data to be either fetched or displayed at once. Pagination is the most common solution to this problem, and Apollo Client has built-in functionality that makes it quite easy to do."),Object(i.b)("p",null,"There are basically two ways of fetching paginated data: numbered pages, and cursors. There are also two ways for displaying paginated data: discrete pages, and infinite scrolling. For a more in-depth explanation of the difference and when you might want to use one vs. the other, we recommend that you read our blog post on the subject: ",Object(i.b)("a",{parentName:"p",href:"https://blog.apollographql.com/understanding-pagination-rest-graphql-and-relay-b10f835549e7"},"Understanding Pagination"),"."),Object(i.b)("p",null,"In this article, we'll cover the technical details of using Apollo to implement both approaches."),Object(i.b)("h2",{id:"offset-based"},"Offset-based"),Object(i.b)("p",null,"Offset based pagination - also called numbered pages - is a very common pattern, found on many websites, because it is usually the easiest to implement on the backend. In SQL for example, numbered pages can easily be generated by using ",Object(i.b)("a",{parentName:"p",href:"https://www.postgresql.org/docs/8.2/static/queries-limit.html"},"OFFSET and LIMIT"),"."),Object(i.b)("h3",{id:"the-offsetlimitpagination-helper"},"The ",Object(i.b)("inlineCode",{parentName:"h3"},"offsetLimitPagination")," helper"),Object(i.b)("p",null,"Apollo Client provides an ",Object(i.b)("inlineCode",{parentName:"p"},"offsetLimitPagination")," helper function that you can use to generate a field policy for every relevant list field."),Object(i.b)("p",null,"This example uses ",Object(i.b)("inlineCode",{parentName:"p"},"offsetLimitPagination")," to generate a field policy for ",Object(i.b)("inlineCode",{parentName:"p"},"Query.posts"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},'import { InMemoryCache } from "@apollo/client/core";\nimport { offsetLimitPagination } from "@apollo/client/utilities";\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: offsetLimitPagination()\n      },\n    },\n  },\n});\n')),Object(i.b)("h3",{id:"using-fetchmore"},"Using ",Object(i.b)("inlineCode",{parentName:"h3"},"fetchMore")),Object(i.b)("p",null,"Apollo lets you do pagination with a method called ",Object(i.b)("a",{parentName:"p",href:"/docs/caching/interaction#incremental-loading-fetchmore"},Object(i.b)("inlineCode",{parentName:"a"},"fetchMore")),". You need to specify what query and variables to use for the update, and how to merge the new query result with the existing data on the client. How exactly you do that will determine what kind of pagination you are implementing."),Object(i.b)("p",null,"Here is an example with numbered pages taken from ",Object(i.b)("a",{parentName:"p",href:"https://stackblitz.com/edit/simple-apollo-angular-example-fetch-more"},"here"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"import { Apollo, QueryRef, gql } from 'apollo-angular';\n\nconst feedQuery = gql`\n  query Feed($offset: Int, $limit: Int) {\n    currentUser {\n      login\n    }\n    posts(offset: $offset, limit: $limit) {\n      id\n      # ...\n    }\n  }\n`;\n\n@Component({ ... })\nclass FeedComponent implements OnInit {\n  apollo: Apollo;\n  feedQuery: QueryRef<any>;\n  feed: any[];\n  itemsPerPage: number = 10;\n\n  ngOnInit() {\n    this.feedQuery = this.apollo.watchQuery<any>({\n      query: feedQuery,\n      variables: {\n        offset: 0,\n        limit: this.itemsPerPage,\n      },\n      fetchPolicy: 'network-only',\n    });\n\n    this.feed = this.feedQuery\n      .valueChanges\n      .subscribe(({data}) => {\n        this.feed = data.feed;\n      });\n  }\n\n  fetchMore() {\n    this.feedQuery.fetchMore({\n      // query: ... (you can specify a different query. feedQuery is used by default)\n      variables: {\n        offset: this.feed.length,\n      },\n    });\n  }\n}\n")),Object(i.b)("p",null,"As you can see, ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore")," is accessible through the ",Object(i.b)("inlineCode",{parentName:"p"},"QueryRef")," object."),Object(i.b)("p",null,"In the example above, ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore")," is a function which calls ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore")," with the length of the current feed as a variable. Whenever you don't pass a query argument to ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore"),", fetch more will use the original ",Object(i.b)("inlineCode",{parentName:"p"},"query")," again with new variables. Once the new data is returned from the server, the ",Object(i.b)("inlineCode",{parentName:"p"},"merge")," function is used to merge it with the existing data, which will cause a re-render of your UI component."),Object(i.b)("p",null,"In the example above, the ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore")," function is called from the UI component:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-html"},'<loading *ngIf="loading"></loading>\n<div *ngIf="!loading">\n  <feed-entry\n    *ngFor="let entry of feed"\n    [entry]="entry"\n    [currentUser]="currentUser"\n    (onVote)="onVote($event)">\n  </feed-entry>\n\n  <a (click)="fetchMore()">Load more</a>\n\n</div>\n')),Object(i.b)("p",null,"One downside of pagination with numbered pages or offsets is that an item can be skipped or returned twice when items are inserted into or removed from the list at the same time. That can be avoided with cursor-based pagination."),Object(i.b)("h3",{id:"setting-keyargs-with-offsetlimitpagination"},"Setting ",Object(i.b)("inlineCode",{parentName:"h3"},"keyArgs")," with ",Object(i.b)("inlineCode",{parentName:"h3"},"offsetLimitPagination")),Object(i.b)("p",null,"If a paginated field accepts arguments besides ",Object(i.b)("inlineCode",{parentName:"p"},"offset")," and ",Object(i.b)("inlineCode",{parentName:"p"},"limit"),", you might need to specify the key arguments that indicate whether two result sets belong to the same list or different lists."),Object(i.b)("p",null,"To set ",Object(i.b)("inlineCode",{parentName:"p"},"keyArgs")," for the field policy generated by ",Object(i.b)("inlineCode",{parentName:"p"},"offsetLimitPagination"),", provide an array of argument names to the function as a parameter:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},'fields {\n  // Results belong to the same list only if both the type\n  // and userId arguments match exactly\n  posts: offsetLimitPagination(["type", "userId"])\n}\n')),Object(i.b)("h2",{id:"cursor-based"},"Cursor-based"),Object(i.b)("p",null,"In cursor-based pagination a cursor is used to keep track of where in the data set the next items should be fetched from. Sometimes the cursor can be quite simple and just refer to the ID of the last object fetched, but in some cases - for example lists sorted according to some criteria - the cursor needs to encode the sorting criteria in addition to the ID of the last object fetched. Cursor-based pagination isn't all that different from offset-based pagination, but instead of using an absolute offset, it points to the last object fetched and contains information about the sort order used. Because it doesn't use an absolute offset, it is more suitable for frequently changing datasets than offset-based pagination."),Object(i.b)("p",null,"In the example below, we use a ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore")," query to continuously load new comments, which then appear at the top. The cursor to be used in the ",Object(i.b)("inlineCode",{parentName:"p"},"fetchMore")," query is provided in the initial server response, and has to be updated whenever more data is fetched."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"const moreComments = gql`\n  query moreComments($cursor: String) {\n    moreComments(cursor: $cursor) {\n      cursor\n      comments {\n        author\n        text\n      }\n    }\n  }\n`;\n\nclass FeedComponent {\n  feedQuery: QueryRef<any>;\n\n  static cursor: any;\n\n  // ...\n  fetchMore() {\n    this.feedQuery.fetchMore({\n      query: moreComments,\n      variables: {\n        // cursor is the initial cursor returned by the original query\n        // this.cursor is the cursor that we update via `updateQuery` below\n        cursor: FeedComponent.cursor,\n      }\n    });\n  }\n  // ...\n}\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"import { InMemoryCache } from \"@apollo/client/core\";\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        feed: {\n          keyArgs: false,\n\n          merge(existing, incoming, {\n            args: { cursor },\n            readField,\n          }) {\n            const merged = existing ? existing.slice(0) : [];\n            let offset = offsetFromCursor(merged, cursor, readField);\n            // If we couldn't find the cursor, default to appending to\n            // the end of the list, so we don't lose any data.\n            if (offset < 0) offset = merged.length;\n            // Now that we have a reliable offset, the rest of this logic\n            // is the same as in offsetLimitPagination.\n            for (let i = 0; i < incoming.length; ++i) {\n              merged[offset + i] = incoming[i];\n            }\n            return merged;\n          },\n\n          // If you always want to return the whole list, you can omit\n          // this read function.\n          read(existing, {\n            args: { cursor, limit = existing.length },\n            readField,\n          }) {\n            if (existing) {\n              let offset = offsetFromCursor(existing, cursor, readField);\n              // If we couldn't find the cursor, default to reading the\n              // entire list.\n              if (offset < 0) offset = 0;\n              return existing.slice(offset, offset + limit);\n            }\n          },\n        }\n      },\n    },\n  },\n});\n\nfunction offsetFromCursor(items, cursor, readField) {\n  // Search from the back of the list because the cursor we're\n  // looking for is typically the ID of the last item.\n  for (let i = items.length - 1; i >= 0; --i) {\n    const item = items[i];\n    // Using readField works for both non-normalized objects\n    // (returning item.id) and normalized references (returning\n    // the id field from the referenced entity object), so it's\n    // a good idea to use readField when you're not sure what\n    // kind of elements you're dealing with.\n    if (readField(\"id\", item) === cursor) {\n      // Add one because the cursor identifies the item just\n      // before the first item in the page we care about.\n      return i + 1;\n    }\n  }\n  // Report that the cursor could not be found.\n  return -1;\n}\n")),Object(i.b)("h2",{id:"relay-style-cursor-pagination"},"Relay-style cursor pagination"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"InMemoryCache")," field policy API allows for any conceivable style of pagination, even though some of the simpler approaches have known drawbacks. Apollo Client comes with a support for ",Object(i.b)("a",{parentName:"p",href:"https://facebook.github.io/relay/graphql/connections.htm"},"Cursor Connections Specification"),"."),Object(i.b)("p",null,"You can check ",Object(i.b)("a",{parentName:"p",href:"https://stackblitz.com/edit/apollo-angular-relay-cursor-pagination?file=app%2Flist.component.ts"},"an example on Stackblitz"),"."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"const COMMENTS_QUERY = gql`\n  query Comments($cursor: String) {\n    comments(first: 10, after: $cursor) {\n      edges {\n        node {\n          author\n          text\n        }\n      }\n      pageInfo {\n        endCursor\n        hasNextPage\n      }\n    }\n  }\n`;\n\nclass FeedComponent {\n  feedQuery: QueryRef<any>;\n\n  static cursor: any;\n\n  // ...\n  fetchMore() {\n    this.feedQuery.fetchMore({\n      query: moreComments,\n      variables: {\n        // cursor is the initial cursor returned by the original query\n        // this.cursor is the cursor that we update via `updateQuery` below\n        cursor: FeedComponent.cursor,\n    }\n    });\n  }\n  // ...\n}\n")),Object(i.b)("p",null,"Whenever you need to consume a Relay pagination API using Apollo Client, ",Object(i.b)("inlineCode",{parentName:"p"},"relayStylePagination")," is a great tool to try first, even if you end up copy/pasting its code and making changes to suit your specific needs."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},'\nimport { relayStylePagination } from "@apollo/client/utilities";\n\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        comments: relayStylePagination(),\n      },\n    },\n  },\n});\n')))}u.isMDXComponent=!0}}]);