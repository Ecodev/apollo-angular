(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{250:function(e,n,t){"use strict";t.d(n,"a",(function(){return d})),t.d(n,"b",(function(){return h}));var r=t(0),i=t.n(r);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=i.a.createContext({}),p=function(e){var n=i.a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=p(e.components);return i.a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.a.createElement(i.a.Fragment,{},n)}},b=i.a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,o=e.originalType,a=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=p(t),b=r,h=d["".concat(a,".").concat(b)]||d[b]||u[b]||o;return t?i.a.createElement(h,s(s({ref:n},c),{},{components:t})):i.a.createElement(h,s({ref:n},c))}));function h(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var o=t.length,a=new Array(o);a[0]=b;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<o;c++)a[c]=t[c];return i.a.createElement.apply(null,a)}return i.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},75:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return s})),t.d(n,"metadata",(function(){return l})),t.d(n,"toc",(function(){return c})),t.d(n,"default",(function(){return d}));var r=t(1),i=t(8),o=(t(0),t(250)),a=["components"],s={title:"Query Splitting"},l={unversionedId:"recipes/query-splitting",id:"version-1.0/recipes/query-splitting",isDocsHomePage:!1,title:"Query Splitting",description:"Prefetching is an easy way to make your applications UI feel faster. You can use mouse events to predict the data that could be needed.",source:"@site/versioned_docs/version-1.0/recipes/query-splitting.md",slug:"/recipes/query-splitting",permalink:"/docs/1.0/recipes/query-splitting",editUrl:"https://github.com/kamilkisiela/apollo-angular/edit/master/website/versioned_docs/version-1.0/recipes/query-splitting.md",version:"1.0",sidebar:"version-1.0/docs",previous:{title:"Small Example",permalink:"/docs/1.0/recipes/simple-example"},next:{title:"Pagination",permalink:"/docs/1.0/recipes/pagination"}},c=[],p={toc:c};function d(e){var n=e.components,t=Object(i.a)(e,a);return Object(o.b)("wrapper",Object(r.a)({},p,t,{components:n,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Prefetching is an easy way to make your applications UI feel faster. You can use mouse events to predict the data that could be needed.\nThis is powerful and works perfectly on the browser, but can not be applied to a mobile device."),Object(o.b)("p",null,"One solution for improving the UI experience would be the usage of fragments to preload more data in a query, but loading huge amounts of data (that you probably never show to the user) is expensive."),Object(o.b)("p",null,"Another solution would be to split huge queries into two smaller queries:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"The first one could load data which is already in the store. This means that it can be displayed instantly."),Object(o.b)("li",{parentName:"ul"},"The second query could load data which is not in the store yet and must be fetched from the server first.")),Object(o.b)("p",null,"This solution gives you the benefit of not fetching too much data, as well as the possibility to show some part of the views data before the server responds."),Object(o.b)("p",null,"Lets say you have the following schema:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"type Series {\n  id: Int!\n  title: String!\n  description: String!\n  episodes: [Episode]!\n  cover: String!\n}\n\ntype Episode {\n  id: Int!\n  title: String!\n  cover: String!\n}\n\ntype Query {\n  series: [Series!]!\n  oneSeries(id: Int): Series\n}\n")),Object(o.b)("p",null,"And you have two Views:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Series Overview: List of all Series with their description and cover"),Object(o.b)("li",{parentName:"ol"},"Series DetailView: Detail View of a Series with its description, cover and a list of episodes")),Object(o.b)("p",null,"The query for the Series Overview would look like the following:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"query seriesOverviewData {\n  series {\n    id\n    title\n    description\n    cover\n  }\n}\n")),Object(o.b)("p",null,"The queries for the Series DetailView would look like this:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"query seriesDetailData($seriesId: Int!) {\n  oneSeries(id: $seriesId) {\n    id\n    title\n    description\n    cover\n  }\n}\n")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-graphql"},"query seriesEpisodes($seriesId: Int!) {\n  oneSeries(id: $seriesId) {\n    id\n    episodes {\n      id\n      title\n      cover\n    }\n  }\n}\n")),Object(o.b)("p",null,"By adding a ",Object(o.b)("a",{parentName:"p",href:"/docs/1.0/features/cache-updates#cache-redirects-with-cacheredirects"},"custom resolver")," for the ",Object(o.b)("inlineCode",{parentName:"p"},"oneSeries")," field (and having dataIdFromObject function which normalizes the cache), the data can be resolved instantly from the store without a server round trip."),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"import { Apollo } from 'apollo-angular';\nimport { toIdValue } from 'apollo-utilities';\nimport { InMemoryCache } from 'apollo-cache-inmemory';\n\n@NgModule({ ... })\nclass AppModule {\n  constructor(apollo: Apollo) {\n    apollo.create({\n      link: // your link,\n      cache: new InMemoryCache({\n        cacheResolvers: {\n          Query: {\n            oneSeries: (_, { id }) => toIdValue(dataIdFromObject({ __typename: 'Series', id })),\n          },\n        },\n        dataIdFromObject,\n      })\n    })\n  }\n}\n")),Object(o.b)("p",null,"A component for the second view that implements the two queries could look like this:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},'import { Apollo } from \'apollo-angular\';\n\nconst QUERY_SERIES_DETAIL_VIEW = gql`\n  query seriesDetailData($seriesId: Int!) {\n    oneSeries(id: $seriesId) {\n      id\n      title\n      description\n      cover\n    }\n  }\n`\n\nconst QUERY_SERIES_EPISODES = gql`\n  query seriesEpisodes($seriesId: Int!) {\n    oneSeries(id: $seriesId) {\n      id\n      episodes {\n        id\n        title\n        cover\n      }\n    }\n  }\n`;\n\n@Component({\n  template: `\n    <h1>{{seriesLoading ? \'Loading...\' : oneSeries.title}}</h1>\n    <img [src]="seriesLoading ? \'/dummy.jpg\' : oneSeries.cover" />\n\n    <h2>Episodes</h2>\n\n    <ul>\n      <li *ngIf="episodesLoading"> Loading...</li>\n      <li *ngIf="!episodesLoading">\n        <img src={episode.cover} />\n        <a href="/episode/{{episode.id}}">{episode.title}</a>\n      </li>\n    </ul>\n  `\n})\nclass AppComponent {\n  apollo: Apollo;\n  seriesId: number;\n  // loading\n  seriesLoading: boolean;\n  episodesLoading: boolean;\n  // data\n  oneSeries: any;\n  episodes: any[];\n\n  ngOnInit() {\n    this.apollo.watchQuery({\n      query: QUERY_SERIES_DETAIL_VIEW\n      variables: { seriesId: this.seriesId }\n    })\n      .valueChanges\n      .subscribe(({loading, data}) => {\n        this.seriesLoading = loading;\n        this.oneSeries = data.oneSeries;\n      });\n\n    this.apollo.watchQuery({\n      query: QUERY_SERIES_EPISODES\n      variables: { seriesId: this.seriesId }\n    })\n      .valueChanges\n      .subscribe(({loading, data}) => {\n        this.episodesLoading = loading;\n        this.episodes = data.oneSeries.episodes;\n      });\n  }\n}\n')),Object(o.b)("p",null,"Unfortunately if the user would now visit the second view without ever visiting the first view this would result in two network requests (since the data for the first query is not in the store yet). By using a ",Object(o.b)("a",{parentName:"p",href:"https://github.com/kamilkisiela/apollo-angular/tree/master/packages/apollo-angular-link-http-batch"},Object(o.b)("inlineCode",{parentName:"a"},"HttpBatchLink"))," those two queries can be send to the server in one network request."))}d.isMDXComponent=!0}}]);