(window.webpackJsonp=window.webpackJsonp||[]).push([[38],{250:function(e,t,n){"use strict";n.d(t,"a",(function(){return u})),n.d(t,"b",(function(){return d}));var o=n(0),r=n.n(o);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},i=Object.keys(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)n=i[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=r.a.createContext({}),p=function(e){var t=r.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=p(e.components);return r.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,a=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=p(n),m=o,d=u["".concat(a,".").concat(m)]||u[m]||b[m]||i;return n?r.a.createElement(d,s(s({ref:t},l),{},{components:n})):r.a.createElement(d,s({ref:t},l))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return r.a.createElement.apply(null,a)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},98:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return s})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return u}));var o=n(1),r=n(8),i=(n(0),n(250)),a=["components"],s={title:"Subscriptions",description:"Get real-time updates from your GraphQL server"},c={unversionedId:"data/subscriptions",id:"version-2.0/data/subscriptions",isDocsHomePage:!1,title:"Subscriptions",description:"Get real-time updates from your GraphQL server",source:"@site/versioned_docs/version-2.0/data/subscriptions.md",slug:"/data/subscriptions",permalink:"/docs/2.0/data/subscriptions",editUrl:"https://github.com/kamilkisiela/apollo-angular/edit/master/website/versioned_docs/version-2.0/data/subscriptions.md",version:"2.0",sidebar:"version-2.0/docs",previous:{title:"Mutations",permalink:"/docs/2.0/data/mutations"},next:{title:"Query, Mutation, Subscription services",permalink:"/docs/2.0/data/services"}},l=[{value:"Overview",id:"overview",children:[{value:"When to use subscriptions",id:"when-to-use-subscriptions",children:[]}]},{value:"Client setup",id:"client-setup",children:[]},{value:"subscribe",id:"subscribe",children:[]},{value:"subscribeToMore",id:"subscribetomore",children:[]},{value:"subscribe vs subscribeToMore",id:"subscribe-vs-subscribetomore",children:[]},{value:"Authentication over WebSocket",id:"authentication-over-websocket",children:[]}],p={toc:l};function u(e){var t=e.components,n=Object(r.a)(e,a);return Object(i.b)("wrapper",Object(o.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("p",null,"In addition to fetching data using queries and modifying data using mutations, the GraphQL spec supports a third operation type, called ",Object(i.b)("inlineCode",{parentName:"p"},"subscription"),"."),Object(i.b)("p",null,"GraphQL subscriptions are a way to push data from the server to the clients that choose to listen to real time messages from the server. Subscriptions are similar to queries in that they specify a set of fields to be delivered to the client, but instead of immediately returning a single answer, a result is sent every time a particular event happens on the server."),Object(i.b)("p",null,"A common use case for subscriptions is notifying the client side about particular events, for example the creation of a new object, updated fields and so on."),Object(i.b)("h2",{id:"overview"},"Overview"),Object(i.b)("p",null,"GraphQL subscriptions have to be defined in the schema, just like queries and mutations:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"type Subscription {\n  commentAdded(repoFullName: String!): Comment\n}\n")),Object(i.b)("p",null,"On the client, subscription queries look just like any other kind of operation:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-graphql"},"subscription onCommentAdded($repoFullName: String!) {\n  commentAdded(repoFullName: $repoFullName) {\n    id\n    content\n  }\n}\n")),Object(i.b)("p",null,"The response sent to the client looks as follows:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescripton"},'{\n  "data": {\n    "commentAdded": {\n      "id": "123",\n      "content": "Hello!"\n    }\n  }\n}\n')),Object(i.b)("p",null,"In the above example, the server is written to send a new result every time a comment is added on GitHunt for a specific repository. Note that the code above only defines the GraphQL subscription in the schema. Read ",Object(i.b)("a",{parentName:"p",href:"#client-setup"},"setting up subscriptions on the client")," and ",Object(i.b)("a",{parentName:"p",href:"https://www.apollographql.com/docs/graphql-subscriptions/"},"setting up GraphQL subscriptions for the server")," to learn how to add subscriptions to your app."),Object(i.b)("h3",{id:"when-to-use-subscriptions"},"When to use subscriptions"),Object(i.b)("p",null,"In most cases, intermittent polling or manual refetching are actually the best way to keep your client up to date. So when is a subscription the best option? Subscriptions are especially useful if:"),Object(i.b)("ol",null,Object(i.b)("li",{parentName:"ol"},"The initial state is large, but the incremental change sets are small. The starting state can be fetched with a query and subsequently updated through a subscription."),Object(i.b)("li",{parentName:"ol"},"You care about low-latency updates in the case of specific events, for example in the case of a chat application where users expect to receive new messages in a matter of seconds.")),Object(i.b)("p",null,"A future version of Apollo or GraphQL might include support for live queries, which would be a low-latency way to replace polling, but at this point general live queries in GraphQL are not yet possible outside of some relatively experimental setups."),Object(i.b)("h2",{id:"client-setup"},"Client setup"),Object(i.b)("p",null,"Because subscriptions maintain a persistent connection, they can't use the default HTTP transport that Apollo Client uses for queries and mutations. Instead, Apollo Client subscriptions most commonly communicate over WebSocket, via the community-maintained ",Object(i.b)("a",{parentName:"p",href:"https://github.com/apollographql/subscriptions-transport-ws"},Object(i.b)("inlineCode",{parentName:"a"},"subscriptions-transport-ws"))," library."),Object(i.b)("p",null,"Let's look at how to add support for this transport to Apollo Client."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"import {WebSocketLink} from '@apollo/client/link/ws';\n\nconst wsClient = new WebSocketLink({\n  uri: `ws://localhost:5000/graphql`,\n  options: {\n    reconnect: true,\n  },\n});\n")),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"import {APOLLO_OPTIONS} from 'apollo-angular';\nimport {HttpLink} from 'apollo-angular/http';\nimport {split, ApolloClientOptions} from '@apollo/client/core';\nimport {WebSocketLink} from '@apollo/client/link/ws';\nimport {getMainDefinition} from '@apollo/client/utilities';\n\n@NgModule({\n  providers: [\n    {\n      provide: APOLLO_OPTIONS,\n      useFactory(httpLink: HttpLink): ApolloClientOptions {\n        // Create an http link:\n        const http = httpLink.create({\n          uri: 'http://localhost:3000/graphql',\n        });\n\n        // Create a WebSocket link:\n        const ws = new WebSocketLink({\n          uri: `ws://localhost:5000/`,\n          options: {\n            reconnect: true,\n          },\n        });\n\n        // using the ability to split links, you can send data to each link\n        // depending on what kind of operation is being sent\n        const link = split(\n          // split based on operation type\n          ({query}) => {\n            const {kind, operation} = getMainDefinition(query);\n            return (\n              kind === 'OperationDefinition' && operation === 'subscription'\n            );\n          },\n          ws,\n          http,\n        );\n\n        return {\n          link,\n          // ... options\n        };\n      },\n      deps: [HttpLink],\n    },\n  ],\n})\nclass AppModule {}\n")),Object(i.b)("p",null,"Now, queries and mutations will go over HTTP as normal, but subscriptions will be done over the websocket transport."),Object(i.b)("p",null,"With GraphQL subscriptions your client will be alerted on push from the server and you should choose the pattern that fits your application the most:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},"Use it as a notification and run any logic you want when it fires, for example alerting the user or refetching data"),Object(i.b)("li",{parentName:"ul"},"Use the data sent along with the notification and merge it directly into the store (existing queries are automatically notified)")),Object(i.b)("p",null,"With ",Object(i.b)("inlineCode",{parentName:"p"},"subscribeToMore")," and ",Object(i.b)("inlineCode",{parentName:"p"},"subscribe"),", you can easily do the latter."),Object(i.b)("h2",{id:"subscribe"},"subscribe"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"subscribe")," is a method available directly in ",Object(i.b)("inlineCode",{parentName:"p"},"Apollo")," service. It works like ",Object(i.b)("inlineCode",{parentName:"p"},"watchQuery")," but it's for GraphQL Subscriptions."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"const COMMENTS_SUBSCRIPTION = gql`\n  subscription onCommentAdded($repoFullName: String!){\n    commentAdded(repoFullName: $repoFullName){\n      id\n      content\n    }\n  }\n`;\n\n@Component({ ... })\nclass CommentsComponent {\n  constructor(apollo: Apollo) {\n    apollo.subscribe({\n      query: COMMENTS_SUBSCRIPTION,\n      variables: {\n        repoName: `kamilkisiela/apollo-angular`\n      },\n      /*\n        accepts options like `errorPolicy` and `fetchPolicy`\n      */\n    }).subscribe((result) => {\n      if (result.data?.commentAdded) {\n        console.log('New comment:', result.data.commentAdded);\n      }\n    });\n  }\n}\n")),Object(i.b)("p",null,"In the example above, the ",Object(i.b)("inlineCode",{parentName:"p"},"CommentsComponent")," subscribes to ",Object(i.b)("inlineCode",{parentName:"p"},"commentAdded")," events and just like in ",Object(i.b)("inlineCode",{parentName:"p"},"watchQuery")," gets receives every emitted result."),Object(i.b)("h2",{id:"subscribetomore"},"subscribeToMore"),Object(i.b)("p",null,"The ",Object(i.b)("inlineCode",{parentName:"p"},"subscribeToMore")," is a bit different than ",Object(i.b)("inlineCode",{parentName:"p"},"subscribe"),". It is a method available on every watched query in ",Object(i.b)("inlineCode",{parentName:"p"},"apollo-angular"),". It works just like ",Object(i.b)("a",{parentName:"p",href:"/docs/2.0/caching/interaction#incremental-loading-fetchmore"},Object(i.b)("inlineCode",{parentName:"a"},"fetchMore")),", except that the update function gets called every time the subscription returns, instead of only once."),Object(i.b)("p",null,"Here is a regular query:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"import { Apollo, QueryRef, gql } from 'apollo-angular';\nimport { Observable } from 'rxjs';\n\nconst COMMENT_QUERY = gql`\n  query Comment($repoName: String!) {\n    entry(repoFullName: $repoName) {\n      comments {\n        id\n        content\n      }\n    }\n  }\n`;\n\n@Component({ ... })\nclass CommentsComponent {\n  commentsQuery: QueryRef<any>;\n  comments: Observable<any>;\n  params: any;\n\n  constructor(apollo: Apollo) {\n    this.commentsQuery = apollo.watchQuery({\n      query: COMMENT_QUERY,\n      variables: {\n        repoName: `${params.org}/${params.repoName}`\n      }\n    });\n\n    this.comments = this.commentsQuery.valueChanges; // async results\n  }\n}\n")),Object(i.b)("p",null,"Now, let's add the subscription."),Object(i.b)("p",null,"Add a function called ",Object(i.b)("inlineCode",{parentName:"p"},"subscribeToNewComments")," that will subscribe using ",Object(i.b)("inlineCode",{parentName:"p"},"subscribeToMore")," and update the query's store with the new data using ",Object(i.b)("inlineCode",{parentName:"p"},"updateQuery"),"."),Object(i.b)("p",null,"Note that the ",Object(i.b)("inlineCode",{parentName:"p"},"updateQuery")," callback must return an object of the same shape as the initial query data, otherwise the new data won't be merged. Here the new comment is pushed in the ",Object(i.b)("inlineCode",{parentName:"p"},"comments")," list of the ",Object(i.b)("inlineCode",{parentName:"p"},"entry"),":"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"const COMMENTS_SUBSCRIPTION = gql`\n  subscription onCommentAdded($repoFullName: String!){\n    commentAdded(repoFullName: $repoFullName){\n      id\n      content\n    }\n  }\n`;\n\n@Component({ ... })\nclass CommentsComponent {\n  commentsQuery: QueryRef<any>;\n\n  // ... it is the same component as one above\n\n  subscribeToNewComments(params) {\n    this.commentsQuery.subscribeToMore({\n      document: COMMENTS_SUBSCRIPTION,\n      variables: {\n        repoName: params.repoFullName,\n      },\n      updateQuery: (prev, {subscriptionData}) => {\n        if (!subscriptionData.data) {\n          return prev;\n        }\n\n        const newFeedItem = subscriptionData.data.commentAdded;\n\n        return {\n          ...prev,\n          entry: {\n            comments: [newFeedItem, ...prev.entry.comments]\n          }\n        };\n      }\n    });\n  }\n}\n")),Object(i.b)("p",null,"and start the actual subscription by calling the ",Object(i.b)("inlineCode",{parentName:"p"},"subscribeToNewComments")," function with the subscription variables:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"@Component({ ... })\nclass CommentsComponent {\n  // ... same component as one above\n\n  ngOnInit() {\n    this.subscribeToNewComments({\n      repoFullName: params.repoFullName,\n    });\n  }\n}\n")),Object(i.b)("h2",{id:"subscribe-vs-subscribetomore"},"subscribe vs subscribeToMore"),Object(i.b)("p",null,"In short:"),Object(i.b)("ul",null,Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"subscribe")," listens to results emitted by a GraphQL Subscription and lets you update one or many queries."),Object(i.b)("li",{parentName:"ul"},Object(i.b)("inlineCode",{parentName:"li"},"subscribeToMore")," listens to GraphQL Subscription as well but is tightly connected with one query.")),Object(i.b)("p",null,"We recommend to use ",Object(i.b)("inlineCode",{parentName:"p"},"subscribe")," in most cases and leave ",Object(i.b)("inlineCode",{parentName:"p"},"subscribeToMore")," for things like pagination."),Object(i.b)("h2",{id:"authentication-over-websocket"},"Authentication over WebSocket"),Object(i.b)("p",null,"In many cases it is necessary to authenticate clients before allowing them to receive subscription results. To do this, the ",Object(i.b)("inlineCode",{parentName:"p"},"SubscriptionClient")," constructor accepts a ",Object(i.b)("inlineCode",{parentName:"p"},"connectionParams")," field, which passes a custom object that the server can use to validate the connection before setting up any subscriptions."),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"import {WebSocketLink} from 'apollo-link-ws';\n\nconst wsLink = new WebSocketLink({\n  uri: `ws://localhost:5000/graphql`,\n  options: {\n    reconnect: true,\n    connectionParams: {\n      authToken: user.authToken,\n    },\n  },\n});\n")),Object(i.b)("blockquote",null,Object(i.b)("p",{parentName:"blockquote"},"You can use ",Object(i.b)("inlineCode",{parentName:"p"},"connectionParams")," for anything else you might need, not only authentication, and check its payload on the server side with ",Object(i.b)("a",{parentName:"p",href:"https://www.apollographql.com/docs/graphql-subscriptions/authentication/"},"SubscriptionsServer"),".")))}u.isMDXComponent=!0}}]);